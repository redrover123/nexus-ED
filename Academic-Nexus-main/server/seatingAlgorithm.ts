import type { User, Room, Seating } from "@shared/schema";

interface GridCell {
  studentId: string | null;
  role: string | null;
}

/**
 * Smart seating algorithm that ensures no two students from the same role
 * sit next to each other (horizontally or vertically, NOT diagonally)
 */
export function allocateSeatingWithConstraints(
  students: User[],
  room: Room
): { grid: GridCell[][]; seatings: Seating[] } {
  const { rows, columns } = room;
  
  // Initialize empty grid
  const grid: GridCell[][] = Array(rows)
    .fill(null)
    .map(() =>
      Array(columns)
        .fill(null)
        .map(() => ({ studentId: null, role: null }))
    );

  // Group students by role
  const byRole = students.reduce(
    (acc, student) => {
      const role = student.role || "UNKNOWN";
      if (!acc[role]) acc[role] = [];
      acc[role].push(student);
      return acc;
    },
    {} as Record<string, User[]>
  );

  // Shuffle each role
  Object.values(byRole).forEach((group) => {
    for (let i = group.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [group[i], group[j]] = [group[j], group[i]];
    }
  });

  const roles = Object.keys(byRole);
  const iterators = roles.map((r) => byRole[r][Symbol.iterator]());
  let currentRoleIdx = 0;

  // Fill grid using round-robin with conflict checking
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < columns; col++) {
      let placed = false;
      let attempts = 0;

      while (!placed && attempts < roles.length) {
        const role = roles[currentRoleIdx];
        const iterator = iterators[currentRoleIdx];
        const student = iterator.next().value;

        if (student && !hasAdjacentRole(grid, row, col, role)) {
          grid[row][col] = { studentId: student.id, role: role };
          placed = true;
        }

        currentRoleIdx = (currentRoleIdx + 1) % roles.length;
        attempts++;

        if (attempts === roles.length && !placed) {
          // If we can't place due to constraints, relax and place anyway
          if (student) {
            grid[row][col] = { studentId: student.id, role: role };
            placed = true;
          }
        }
      }
    }
  }

  // Convert grid to seatings array
  const seatings: Seating[] = [];
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < columns; col++) {
      if (grid[row][col].studentId) {
        seatings.push({
          id: "", // Will be generated by DB
          examId: "", // Set by caller
          roomId: "", // Set by caller
          studentId: grid[row][col].studentId!,
          row,
          column: col,
          createdAt: new Date(),
        });
      }
    }
  }

  return { grid, seatings };
}

/**
 * Check if placing a student from a role at (row, col) violates adjacency constraint
 */
function hasAdjacentRole(
  grid: GridCell[][],
  row: number,
  col: number,
  role: string
): boolean {
  // Check up
  if (row > 0 && grid[row - 1][col].role === role) return true;
  // Check down
  if (row < grid.length - 1 && grid[row + 1][col].role === role)
    return true;
  // Check left
  if (col > 0 && grid[row][col - 1].role === role) return true;
  // Check right
  if (col < grid[row].length - 1 && grid[row][col + 1].role === role)
    return true;

  return false;
}
